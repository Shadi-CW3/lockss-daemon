<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book-part-wrapper >
<book-part-wrapper  xmlns:xlink="http://www.w3.org/1999/xlink"  dtd-version="2.0" xml:lang="en" content-type="research-article">
    <collection-meta collection-type="book-series">
        <collection-id collection-id-type="doi">10.1145/acmconferences</collection-id>
        <title-group>
            <title>ACM Conferences</title>
        </title-group>
    </collection-meta>
    <book-meta>
        <book-id book-id-type="acm-id">3323873</book-id>
        <book-id book-id-type="doi">10.1145/3323873</book-id>
        <book-title-group>
            <book-title>Proceedings of the 2019 on International Conference on Multimedia Retrieval</book-title>
            <alt-title alt-title-type="acronym">ICMR '19</alt-title>
        </book-title-group>
    </book-meta>
    <book-part book-part-type="chapter" xml:lang="en">
        <book-part-meta>
            <book-part-id book-part-id-type="acm-id">3325009</book-part-id>
            <book-part-id book-part-id-type="other">http://dlnext.acm.org/doi/10.1145/3323873.3325009</book-part-id>
            <book-part-id book-part-id-type="doi">10.1145/3323873.3325009</book-part-id>
            <subj-group subj-group-type="ccs2012">
                <compound-subject>
                    <compound-subject-part content-type="code">10010147.10010257.10010258.10010262</compound-subject-part>
                    <compound-subject-part content-type="text">Computing methodologies~Machine learning~Learning paradigms~Multi-task learning</compound-subject-part>
                    <compound-subject-part content-type="weight">500</compound-subject-part>
                </compound-subject>
            </subj-group>
            <title-group>
                <title>Learning Task Relatedness in Multi-Task Learning for Images in Context</title>
            </title-group>
            <contrib-group>
                <contrib contrib-type="author" id="artseq-00001">
                    <contrib-id contrib-id-type="person_id" authenticated="false">P6844425</contrib-id>
                    <name name-style="western">
                        <surname>Strezoski</surname>
                        <given-names>Gjorgji</given-names>
                    </name>
                    <aff>University of Amsterdam, Amsterdam, Netherlands</aff>
                    <email>g.strezoski@uva.nl</email>
                    <role>Author</role>
                </contrib>
                <contrib contrib-type="author" id="artseq-00002">
                    <contrib-id contrib-id-type="person_id" authenticated="false">P6844426</contrib-id>
                    <name name-style="western">
                        <surname>van Noord</surname>
                        <given-names>Nanne</given-names>
                    </name>
                    <aff>University of Amsterdam, Amsterdam, Netherlands</aff>
                    <email>n.j.e.vannoord@uva.nl</email>
                    <role>Author</role>
                </contrib>
                <contrib contrib-type="author" id="artseq-00003">
                    <contrib-id contrib-id-type="person_id" authenticated="false">P6844427</contrib-id>
                    <name name-style="western">
                        <surname>Worring</surname>
                        <given-names>Marcel</given-names>
                    </name>
                    <aff>University of Amsterdam, Amsterdam, Netherlands</aff>
                    <email>m.worring@uva.nl</email>
                    <role>Author</role>
                </contrib>
            </contrib-group>
            <pub-date date-type="publication">
                <day>05</day>
                <month>06</month>
                <year>2019</year>
            </pub-date>
            <fpage>78</fpage>
            <lpage>86</lpage>
            <permissions>
                <copyright-year>2019</copyright-year>
                <copyright-holder>ACM</copyright-holder>
                <license license-type="acmlicensed">
                    <license-p>Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. Copyrights for components of this work owned by others than the author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee. Request permissions from Permissions@acm.org.</license-p>
                </license>
            </permissions>
            <self-uri content-type="pdf" xlink:href="3323873.3325009.pdf" />
            <abstract>
                <p>Multimedia applications often require concurrent solutions to multiple tasks. These tasks hold clues to each-others solutions, however as these relations can be complex this remains a rarely utilized property. When task relations are explicitly defined based on domain knowledge multi-task learning (MTL) offers such concurrent solutions, while exploiting relatedness between multiple tasks performed over the same dataset. In most cases however, this relatedness is not explicitly defined and the domain expert knowledge that defines it is not available. To address this issue, we introduce Selective Sharing, a method that learns the inter-task relatedness from secondary latent features while the model trains. Using this insight, we can automatically group tasks and allow them to share knowledge in a mutually beneficial way. We support our method with experiments on 5 datasets in classification, regression, and ranking tasks and compare to strong baselines and state-of-the-art approaches showing a consistent improvement in terms of accuracy and parameter counts. In addition, we perform an activation region analysis showing how Selective Sharing affects the learned representation.</p>
            </abstract>
            <kwd-group>
                <kwd>multi-task learning</kwd>
                <kwd>multimedia</kwd>
                <kwd>task grouping</kwd>
            </kwd-group>
            <funding-group specific-use="FundRef">
                <award-group id="award1">
                    <funding-source id="GS1">
                        <institution-wrap>
                            <institution>NWO</institution>
                        </institution-wrap>
                    </funding-source>
                    <award-id rid="GS1">628.007.004</award-id>
                </award-group>
            </funding-group>
        </book-part-meta>
        <body>
            <sec>
                <title />
                <p content-type="pdf-extracted-text">Learning Task Relatedness in Multi-Task Learning for Images in Context Gjorgji Strezoski University of Amsterdam Amsterdam, Netherlands Nanne van Noord University of Amsterdam Amsterdam, Netherlands n.j.e.vannoord@uva.nl Marcel Worring University of Amsterdam Amsterdam, Netherlands Multimedia applications often require concurrent solutions to multiple tasks. These tasks hold clues to each-others solutions, however as these relations can be complex this remains a rarely utilized property. When task relations are explicitly defined based on domain knowledge multi-task learning (MTL) offers such concurrent solutions, while exploiting relatedness between multiple tasks performed over the same dataset. In most cases however, this relatedness is not explicitly defined and the domain expert knowledge that defines it is not available. To address this issue, we introduce Selective Sharing, a method that learns the inter-task relatedness from secondary latent features while the model trains. Using this insight, we can automatically group tasks and allow them to share knowledge in a mutually beneficial way. We support our method with experiments on 5 datasets in classification, regression, and ranking tasks and compare to strong baselines and state-of-the-art approaches showing a consistent improvement in terms of accuracy and parameter counts. In addition, we perform an activation region analysis showing how Selective Sharing affects the learned representation. CCS CONCEPTS • Computing methodologies → Multi-task learning; ACM Reference Format: Gjorgji Strezoski, Nanne van Noord, and Marcel Worring. 2019. Learning Task Relatedness in Multi-Task Learning for Images in Context. In International Conference on Multimedia Retrieval (ICMR '19), June 10–13, 2019, Ottawa, ON, Canada. ACM, New York, NY, USA, 9 pages. https://doi.org/10. 1145/3323873.3325009 1 INTRODUCTION In many multimedia applications, there are not only multiple sources of information, but a multitude of tasks to perform as well. Whether segmenting sketches of animals [38], recognizing birds by attribute appearance [1], attributing artists to paintings [42] or classifying facial features [11, 27], state-of-the-art results [1, 11, 27] show that exploiting task relatedness in a multi-task learning (MTL) setting benefits performance. For example, an artwork can be described by Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. Copyrights for components of this work owned by others than the author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee. Request permissions from permissions@acm.org. ICMR '19, June 10–13, 2019, Ottawa, ON, Canada 2019 Copyright held by the owner/author(s). Publication rights licensed to ACM. ACM ISBN 978-1-4503-6765-3/19/06. . . $15.00 https://doi.org/10.1145/3323873.3325009 Figure 1: Illustrating the gradient flow of the individual task branches as they group through the training epochs with the simplifying assumption that all task specific branches are identical and identically initialized. its creation period, style, technique, genre, type, or artist, as well as with content descriptors such as brush-stroke frequency, lighting direction or repeated texture patterns. Learning to recognize or predict each of these contextual attributes is a separate task, the solution of which may benefit the other tasks in the pool. This way, if one of the attributes is missing, or unknown, the knowledge from learning other contextual attributes, both visual and textual, can help in narrowing down the space of potential values for the missing attribute. In other words, if we recognize a painting has been made in the 17th century in the Dutch school of painting and contains a gray cloudy landscape, in an artist attribution task we could short-list a few artists as the possible creator. The main benefit of MTL is leveraging multiple shared information sources, especially when a mutual dependence is present to improve the process of solving multiple tasks at once [9, 23, 38]. While theoretically the gain from MTL is enticing, fully exploiting its benefits is a tedious process in practice. Often this is due to the lack of expert knowledge about the data posing the MTL challenge. Knowing how to setup the shared representation in a MTL setup can play a key difference in the model's performance. However, a recurring theme in existing MTL approaches is that the task relatedness still needs to be specified before training based on prior knowledge. Noticing task relatedness comes naturally to humans, but for MTL models to do the same a high level of domain expert knowledge is required which is often expensive and rarely available. In this work we propose a method - Selective Sharing - for learning task relatedness during training, and modifying the network architecture on-the-fly with no prior knowledge. Selective Sharing makes it possible to optimize multiple tasks at once by only sharing the weights and parameters between tasks. Sharing occurs when their relatedness satisfies an influence metric derived from latent secondary features, such as gradient factors. As visible in Figure 1, we measure task similarity during training and cluster tasks with similar responses to the same stimuli. Upon satisfying the metric these tasks form groups and continue training together. This approach iteratively reduces the size of the parameter space compared to other MTL approaches without the requirement of a prior inter-task relationship specification. Grouping tasks allows them to share and fit a mutual parameter space. This reduces trainable parameter count in half per pair of tasks, once one of the task specific branches is no longer used. With a greedy starting position, the parameter reduction properties of Selective Sharing shorten training epoch duration and decrease memory requirements for the final model. In this paper we elaborate on the following three contributions: • We propose Selective Sharing, a new approach for MTL that performs data driven task grouping without requiring prior knowledge. • We demonstrate our approach's ability to make explicit the latent task relatedness in MTL supported with task specific activation region analyses. • We improve or maintain performance in classification, re gression, and ranking tasks while reducing the size of the parameter space. 2 RELATED WORK MTL has developed significantly from the moment it was introduced [4, 40]. While originally it was a 'one size fits all' methodology, multiple MTL design patterns have been identified depending on the type of data that is being modeled, the type of sharing between the different tasks or the different levels on which a mutual representation is created. Additionally, with MTL comes a natural urge to simplify the models at hand and group the tasks that would benefit each other's learning process. With this mutually beneficial task relationship in mind, there are numerous domains and modalities [9, 13, 14, 23, 36, 38, 45, 49] where the MTL methodology can be applied. As such, MTL is often used implicitly without a specific reference in methods such as transfer learning and fine-tuning [4, 39] as well. Given this broad scope of MTL in this section we focus on MTL in the context of systems that exploit visual information with their accompanying metadata. 2.1 Multi-task Learning Whenever we find ourselves optimizing for more than one loss function, we are essentially doing MTL. This is in contrast to single task learning (STL) where we optimize only one loss function [35]. Caruana in 1997 also defined it as training tasks in parallel while using a shared representation [4]. While this is a simple definition, it does cover a vast portion of the possible problem space and allows for a lot of freedom in its interpretation. In MTL there are two general ways in which we can define a problem and several more ways to apply an MTL approach with respect to the nature of the problem. If we are going to label an MTL problem by whether the tasks are sharing a label space or not, it can be either a Homogeneous MTL problem or a Heterogeneous MTL problem. 2.1.1 Homogeneous and Heterogeneous MTL. Homogeneous MTL problems are usually defined over existing multiclass classification problems that do not naturally consist of multiple tasks. This definition allows us to study the effects of MTL in a controlled environment, often competing against strong specialized STL benchmarks. Massimiliano and Theodoros in [8] demonstrate a homogeneous formulation by creating 139 binary tasks predicting whether a pupil belongs to a school or not. In a visual domain the same can be achieved with the the USPS dataset [12] as Kumar et al. show in [19]. Yang and Hospedales [47] make use of the homogeneous formulation over the MNIST dataset [21]. In summary, with a homogeneous definition the target space is transformed to fit the MTL paradigm by splitting each target into a separate one vs. all task. Heterogeneous MTL primarily occurs in problems and datasets that contain multiple types of labels existing in separate spaces for their data [46]. For example, an artwork can have a label for the artist, the creation period, the type and materials of the artwork. All of those labels represent different tasks like artist attribution or creation period estimation [41]. Zhang et al [51] demonstrate the same for facial landmarks and Zamir et al. [49] show a heterogeneous formulation over multiple domains and target spaces at the same time. Regardless of the problem formulation, following Caruana's definition of MTL we know that a shared representation is key. But how do we decide what to share, to which extent and between which tasks should the sharing occur? 2.1.2 Hard and Soft Parameter Sharing. Most MTL approaches share the same base structure for feature extraction [1, 8, 11, 17, 25, 26, 32, 49–51] and then continue to branch out, intertwine or widen the model's parameter space. Sharing is an essential part of MTL and can be categorized as hard sharing or soft sharing. Hard parameter sharing is the most commonly used approach for MTL in neural networks and goes back to [4]. It is generally applied by sharing the hidden layers between all tasks, while keeping several task-specific output layers. Hard parameter sharing greatly reduces the risk of over-fitting. In fact, Baxter [2] showed that the risk of over-fitting the shared parameters is order N (where N is the number of tasks) smaller than over-fitting of the task-specific parameters, i.e. the output layers. This makes sense intuitively: the more tasks we learn simultaneously, the more our model has to find a general representation that is suited for all of the tasks and our chance of over-fitting on our original task is smaller. In contrast, soft parameter sharing each task has its own model with separate parameters. This means that there is no physical layer structure that is shared between the different tasks, but rather it is an intermediate set of parameters that is shared. In this case, sharing parameters acts as a weight regularizer as Duong et al. show in [7]. Further, Yang et al. in [48] show that soft sharing regularization works on factorized representations (Tensor-Train [34] or Tucker [43]) as well. This kind of sharing promotes task independence, but keeps the parameter space similar so that tasks can still influence each other. Similarly, Misra et al. [31] introduced Cross-Stitch Networks that rest on the soft sharing paradigm. Initially their approach starts with identical structures between tasks and soft parameter sharing. Different from [48] and [7], in this model the sharing is determined by cross-stitch units, whose task is to learn a linear combination of the output of the previous layers from both structures. A shortcoming of these approaches is that they require knowledge of the parametric form of the tasks at hand. In [1], Mejjati et al. treat their tasks as random variables for which statistical dependence can be measured and maximized. While it achieves comparable performance on several ranking and regression tasks, their approach relies on an existing dataset that mimics the distribution of the tasks. In this way, for this method to obtain the reported performance, prior knowledge of the distributions for each task is always necessary. Inspired by [1], in Selective Sharing we aim to obtain this knowledge on the fly, while training the model in a greedy fashion accumulating such information as it becomes available in the back-propagated gradients. 2.1.3 Task Grouping. Choosing which tasks share parts of their parameter space proves to be beneficial when prior knowledge about this entanglement is present. Long and Wang [28] introduced the concept of Deep Relationship Networks where they impose matrix priors on the shared fully connected layers which allows the model to learn the task relationships. This is a similar method to Bayesian MTL models [6, 29], who essentially group the tasks based on this predefined relationship matrix. Liu et al [24] propose a dynamic greedy bottom-up approach to task grouping to overcome the predefined sharing matrix problem. Instead of hard-coding task dependencies, they dynamically widen the model by creating new branches as training progresses. However, this method has a risk of every task becoming a separate branch in the structure and therefore limits sharing and parameter tuning between tasks. Other approaches have tried to generalize existing approaches to MTL like Yang et al. [47], who uses tensor factorization to split the parameter space into shared and task specific parameters of every layer. Sluice networks introduced by Ruder et al. [37] aggregate multiple MTL approaches into one by creating a task hierarchy in MTL problems to maximize relatedness utilization regardless of how related they actually are. Regardless of the scenario, task grouping methods tend to rely on prior task relationship knowledge, or extensive statistical analysis prior to model design. In this paper we address some of the issues that arise with deep MTL models. Namely, we stray away from the predefined sharing structure and let the model decide the sharing parties and their structure. This allows for flexibility and dynamically adapting models that tune themselves to the tasks at hand. Learning the underlying task relatedness based on the supervision responses over a shared input, allows for grouping tasks on the fly during training. The resulting network then provides additional insight (explicit task relations) into the data we are analyzing. 3 SELECTIVE SHARING In any deep learning system, gradients flow from the final layers of the model towards the starting ones carrying a corrective signal for the weights and biases along the way. They are a way for the model to know where and how much it should correct its trainable parameters. Selective Sharing is based on the assumption that the identically constructed task specific estimators, sharing the same input and feature extraction platform, would manifest a correlation between the back-propagated gradients for related tasks. Following this, we define an MTL problem as: • A set of tasks T with cardinality |T |. • A set of related tasks Rk = T /tk for each task tkϵT . • A set of task dependent loss functions Et generating task specific gradients Gt for the task specific targets Kt . • A set of identical task specific estimators with identical layers lt and weights wlt .1 Not having the constraint of requiring domain specific task relatedness knowledge, this approach allows for formulating any set of classification, regression or ranking problem into the MTL paradigm and can be used for discovering relations between contextual attributes in large bodies of data. For example, if we observe an MTL model trained for classifying written digits with one branch per digit, we can postulate that our optimization scheme will generate similar corrections for the branch specific weights in the branches related to classes '1', '4' and '7' (see Figure 5), in the case where the input image is the number seven. Having a shared input and distinct gradient flows, we can study the gradients and their factors which depict the behavior of task specific estimators, divulging information about intertask relatedness and supervision signal similarity. In this way, we define three functional structures of our approach: the feature extraction block, the shared representation block and the task specific estimators (branches) as illustrated in Figure 2. The feature extraction block provides the initial representation for the input data. Depending on the problem and whether it should be trained or not, the feature extraction block can range in form from a CNN to SIFT, HOG or any other handcrafted features that apply. The features are then propagated forward through the hard shared layer, which is the base representation Selective Sharing is working with. From this point, task specific estimators branch out with identical blocks (identical layers It with identical weights wlt ) per task t with Kt targets, with a task specific loss function E =12 k∈K(k - yk)2 for example Mean Squared Error, k being the activation of output unit k with input xk , and yk as the groundtruth for the same units producing the task specific gradients Gt . Our approach is applicable in both heterogeneous and homogeneous problems. For homogeneous MTL problems (MNIST, CIFAR, 1As all equations are task-specific, t is omitted in further notation for simplicity and readability. Inputs, outputs, targets and activations follow the classic machine learning naming convention (x, , y, a). Figure 2: A high level overview of the Selective Sharing architecture. All tasks share the same input data (purple) and pass through the same feature extraction block before arriving to the shared representation (blue block). From the final shared representation all tasks branch in identical estimators with a different output (per task). With each mini-batch we accumulate gradients and factorize them. After clustering the factorized gradients from the set of tasks, the architecture is recomputed to group tasks whose gradients belong to the same factor cluster which implies keeping one estimator and discarding the rest so that the group tasks would only differ in their output. INPUT DATA PROPAGATE FORWARD CALCULATE LOSS CALCULATE GRADIENTS AGGREGATE GRADIENTS DID THE EPOCH END? NO YES FACTORIZE GRADIENTS CLUSTER FACTORS DID NEW GROUPS FORM? MERGE BRANCHES FROM CHOSEN CLUSTERS RECOMPUTE COMPUTATIONAL GRAPH YES NO DID THE MODEL CHANGE IN THE PAST 3 EPOCHS? YES LOCK MODEL'S STRUCTURE NO OPTIMIZE FINAL STRUCTURE FACTOR CLUSTERING TASK SPECIFIC GRADIENT FACTORIZATION TASK SPECIFIC GRADIENT CAPTURE BRANCH MERGING AND RECALCULATION EARLY STOPPING MECHANISM GROUP FORMATION CONFITIONAL START END Figure 3: An operational flow diagram of the Selective Sharing method. The different stages in the method are color coded and the region enclosed by the dashed line represents the early stopping conditions. OmniGlot, Birds) we define each category as a binary classification task. Our model changes accordingly with duplication of the estimator for each task. In a heterogeneous (OmniArt) problem we optimize for multiple different estimators suitable for the task at hand. The name Selective Sharing is derived from an important property of the method itself, which is allowing the model to select the tasks where sharing should occur, without it being specifically programmed to do so. There is however, a general directive for the sharing. The directive is given before the model training starts and is essentially the clustering condition. Depending on the goal the model can perform sharing by: • Similarity maximizes the model's exposure to data samples which have a high probability of sharing similar primitive features or high level semantics. • Dissimilarity allows for an increase in information entropy which can prolong training times, but results in better gen eralization. • Variance favors large task clusters so it strives towards learning a more complete representation. 3.1 Task specific gradient capture The Selective Sharing pipeline starts by tapping into the gradient flow at the point where the model starts branching out for different tasks, immediately after the hard shared representation layer and task specific layer It . In that point we define the gradient as Gt and compute it as a gradient for weights wij ∈ It as follows (bias excluded for simplicity): Gt =∂Et ∂wij= k ∈Kt(k - yk )д′k(xk ) ∂∂wijxk, (1) if we continue to decompose activation xk and define the gradient from the previous layer for task t as δt j = д′j(xk) k∈Kt δkwjk, the gradient gets the final form of: Gt = δt jai , (2) Each Gt tensor is a gradient from a separate task estimator. At the hard shared representation layer where дj is the activation function for node j in layer It , wij are the weights connecting the node j in layer It with the node i in layer It - 1 and ai is the activation or output for node i in layer It . Using the same notation, we define δk as all the terms that involve the value of a unit at index k with respect to the expected target Kt and zk is the input to node k of layer It for task t. Since these captured gradients represent the data being clustered on basis of task relatedness, we can consider them as secondary features to the ones we learn for the data representations. Because the gradient capture is performed in a fully connected section between the hard shared representation and task specific branches, the gradient affecting the hard shared layer is: G = |T | t =1 Gt , (3) When observing a gradient in a fully connected section of the model, there is an influence between each pair of input and output nodes. Despite their high dimensionality, we collect and label these gradient tensors making the resulting group tensor a clustering candidate and name it after the index of the task specific estimator (e.g. in our digit recognition model a gradient coming from estimator seven would have the label seven). Keeping in mind that this capture is performed between each task branch and the hard shared representation layer a rather compact representation with little information loss is necessary in order to perform the task correlation analysis. Additionally, this process is spanning through hundreds of examples passing in an epoch and the aggregated information loss can be substantial. For this reason we utilize the Tensor Train decomposition [34] which not only allows for a compact representation of tensors, but eases the application of linear algebra operations. 3.2 Task specific gradient factorization Depending on the dimensions (number of units) of the layers where they are calculated, gradients can become high dimensional tensors. This is particularly visible in MTL pipelines with multiple branches, as they all generate their own gradients. This type of rich representation is informative, but poses a problem in a setting where aggregation and quick analysis is required. Tensor train decomposition [34] is a mechanism that transforms a given tensor Gt with d elements Gt (f1, f2, ..., fd ) into a more compact representation Bt : BT = d i=1 Di (αi-1, fi , αi ), (4) where each of the Di elements are matrices representing a factor of the tensor Gt and the αf represent the index matrix of dimension (factor) f . If we aim to reconstruct the whole tensor a multiplication needs to be performed between all of the factors and then a summation of the auxiliary α index nodes. In a reconstruction setting these operations are performed for as many times as there are dimensions in the decomposed tensor. From them, branch specific matrices Ct are produced with dimensions [num_batches · shape(Bt )] where t is the index of the task. Ct = B0B1B2...BmT , (5) The Ct from equation 5 are matrices which after being normalized continue to the clustering phase of Selective Sharing where the task groups are defined. 3.3 Factor clustering Due to their high dimensionality, density and the critical time period in which clustering occurs, a robust fast high dimensional clustering approach is required. Robust to noise and efficient in handling dense representations, HDBSCAN [3, 30] is the clustering CORE DISTANCE CORE DISTANCE dreach( , ) Figure 4: Illustrating the definition of core and mutual reachability distances with two clusters. Core distance we define as the radius of each circle enclosing the factors (marked with X). The mutual reachability distance is defined as the distance between the two centroids according to equation 6. approach we utilize for our method. It uses a simple distance metric which allows for fast cluster formation and easy selection: dM-k (Cti ,Ctj ) = max corek (Cti ),corek (Ctj ),d(Cti ,Ctj ) , (6) where corek is the distance to the k - th nearest neighboring factor and provides a sort of density estimation, d(Cti ,Ctj ) is the original metric distance between Cti and Ctj (see Figure 4). This distance metric is called mutual reachability distance. Under this metric, dense points (with low core distance) remain the same distance from each other whereas sparser points are pushed away to be at least their core distance away from any other point. Its simple definition (eq. 6) allows for distance metric manipulations so we can effectively alter the task group formation conditions when computing the Rt sets of related tasks. Clustering is performed over the stacked and normalized gradient factors per task at the end of each epoch. This process repeats until all of the tasks have formed a group with at least one other task, or there have been no changes to the model's architecture for three consecutive epochs. If no stop criteria exists, as training progresses, errors get smaller and gradients sparser, it is expected behavior that all tasks form one group, reverting back to a hard shared MTL approach defying the purpose of grouping in the first place. 3.4 Branch merging and recalculation When tasks form a group in the clustering phase, it implies that they have similar reactions to the same input, therefore the weights of the layers in their branches should be in a similar state at that point in time. The starting condition of all branches having identical initial states supports this hypothesis. With identical architectures per branch, merging can be performed by regular arithmetic operations in the order of keeping the pairwise maximum, minimum and mean weights, or just keeping the branch whose aggregated loss was the lowest in the newly formed group. For the experimental design we keep the branch with the lowest aggregated loss with its weights and parameters intact. 4 EXPERIMENTAL DESIGN We evaluate Selective Sharing on several problems, both homogeneous and heterogeneous ones. By performing various classification, regression and ranking tasks on five datasets we aim to: • Illustrate the reasoning behind the method and the group for mation logic both visually and intuitively on simple datasets (MNIST and CIFAR10) • Evaluate group formation handling when optimizing for a very large number of tasks (50) (OmniGlot) • Evaluate performance in ranking problems and compare against classic and current MTL approaches (UCSD-Birds, OmniGlot) • Demonstrate performance in a real large-scale multi-modal MTL problem (OmniArt) 4.1 Datasets and Tasks The MNIST [21] handwritten digit classification problem and CIFAR10 [18] are well established benchmarks containing 70K and 60K images. For both experiments we split the data into 50K (MNIST) and 40K (CIFAR10) train, 10K validation and 10K test images spanning 10 target classes. In the CIFAR10 experiment we normalized the images with the training dataset mean. For MNIST we did not use any augmentation or preprocessing steps. As setup in a homogeneous setting we treat the ten target classes as ten binary classification tasks with the standard train/test splits. OmniGlot [20] contains 1,623 handwritten from 50 alphabets. Each character is drawn in square regions which we resized to 28x28 pixels and the model is tasked with classifying the alphabet of origin for the input character resulting in a 50 task MTL problem. Caltech-UCSD Birds dataset [44] provides 11.788 bird images over 200 bird species with 312 binary attribute annotations. For state of the art comparison, we compare on ten target attributes obtained with spectral clustering using the FSIC as the similarity measure [1]. For the ten selected attributes, 10 MTL ranking tasks are defined. For each target attribute (ranking task) we rank pairs of images based on the estimated presence of that attribute on 10% of the dataset. The remaining 80% is used for training and 10% used for validation. OmniArt [41] provides the data for a comprehensive real largescale multi-modal MTL problem. This artistic dataset features over 2M data samples and presents a natural heterogeneous MTL problem described by multiple interconnected contextual attributes, making it ideal for testing our method. For the purpose of this experiment we select a subset of OmniArt containing only artworks of the type painting. Having a consistent artwork type allows us to better illustrate the connection between the tasks. Our selected subset consists of 133K paintings for which we are using a 80-10-10 split for training, validation and testing and compare against an MTL baseline introduced with the dataset itself [42]. 4.2 Model setup and Training For MNIST we define a two layer CNN with 20 5x5 filters in the first layer, and 40 filters of size 5x5 in the second. The convolutions are batch normalized and followed by max pooling layers with stride two. As a feature cutoff point, we apply a 640 unit fully connected (FC) layer. For STL this layer is followed by a sequence of 100 unit Table 1: Mean performance comparison for MNIST, CIFAR10 and OmniGlot for Selective Sharing, an STL and MTL baseline. Prior knowledge for relatedness between the 50 OmniGlot alphabets was missing so a fair comparison is not possible. Dataset MNIST CIFAR10 OmniGlot Metric Accuracy (%) Accuracy (%) Error Rate STL Baseline [5] 98.0 92.6 0.34 MTL Baseline 96.8 90.3 0.29 [47] MTL Stitching [31] 98.4 92.1 n/a MTL MSD [1] 98.7 91.9 n/a Selective Sharing - Similarity 99.0 92.7 0.24 Table 2: Ranking performance in UCSD Birds. Kendall's Tau correlation scores x 100 ± std. x 100 are presented. Attributes for which Selective Sharing has superior performance are highlighted in gray. Att. MTL RegMTL [8] AMTL [22] MTL-MSD [1] Ours 1 51.1±1.22 60.4±3.24 59.4±4.26 58.7±3.69 56.1±1.44 2 44.3±0.41 54.2±4.33 53.4±3.09 53.9±2.46 54.9±2.28 3 52.7±0.27 61.7±2.69 60.1±4.44 60.1±1.53 61.2±1.31 4 49.9±1.11 54.2±4.17 56.5±1.76 54.4±1.29 56.1±1.25 5 50.0±0.70 55.0±3.55 51.9±6.61 53.2±2.09 55.6±1.13 6 50.0±0.14 54.0±3.51 55.8±1.09 52.3±1.95 56.7±1.74 7 41.1±1.31 49.0±10.49 50.8±5.46 51.5±1.03 49.4±0.99 8 59.0±2.63 63.0±2.32 63.0±1.02 60.7±1.91 63.4±1.86 9 51.4±0.98 53.9±5.16 55.6±2.66 55.7±1.15 56.1±1.24 10 51.2±0.84 60.3±4.21 59.5±6.81 61.0±1.70 62.2±1.83 and 50 unit FC layers ending in a ten unit softmax output layer [5]. For MTL, the 640 unit hard shared representation is followed by the same classification block from the STL setup, duplicated ten times. We replace the ten-way softmax output with one sigmoid unit per block that performs binary classification. For binary classification we use binary cross-entropy and in STL approaches - categorical cross-entropy as the loss function. For CIFAR10 we train a VGG-16 network from scratch with an average pooling cutoff at the end. For STL, the average pooling is followed by 1024 and two 100 dimensional FC layers with a 10-way softmax at the end. For the MTL experiment we rely on the 1024 dimensional FC layer as the hard shared layer and define 10 task specific branches with two 100 unit FC layers and a sigmoid unit for binary classification. For Caltech-UCSD Birds 200 (CUB-200), the tasks are posed as ten ranking problems, each ranking pairs of images according to the predicted presence of the attribute in the input images. A pretrained VGG-16 network constitutes the feature extraction unit, followed by a 2048 dimensional FC layer as the hard shared representation. Our 10 ranking blocks have two FC layers of 512 and 256 units followed by an output unit. We train our ranking blocks with a paired ranking loss function: lrank (xi, xj ; f ) = max(0, 1 - (f (xi ) - f (xj )))2, (7) For OmniGlot we train the same three layer CNN from [47] with a difference in the classification setup and input dimensions (resized to 28x28px), however, we define 50 tasks and do not make Table 3: Performance comparison for the OmniArt dataset between a baseline STL approach, a baseline MTL approach and Selective Sharing with Similarity. For every attempt we list the final number of trainable parameters, which for the STL approach is the sum of all the trainable parameters for all tasks. Since the feature extraction is fixed, the parameter count contains only the task specific branches and the hard shared layer. Task AA GC CCC SC MC STC CYE # Params Lock Epoch # Branches Metric Accuracy (%) MAE (years) STL Baseline 28.0 25.0 32.1 24.7 41.3 19.2 144.32 3,487,664 N/A N/A MTL Baseline 31.0 26.2 27.7 23.0 42.0 22.1 135.43 1,630,664 N/A 7 Selective Sharing - Similarity 33.8 28.0 29.0 27.6 44.1 21.2 128.11 908,264 10 3 a character level distinction. For the STL experiments we define a FC layer of 300 units, two FC layers of 100 units with 0.2 dropout and a 50 class softmax layer at the end. For the MTL experiments we rest on the same 300 unit hard shared FC layer and define 50 task specific estimators. The task estimators have the STL estimator design, but perform binary classification at the end. For MNIST, CIFAR, OmniGlot and UCSD-Birds we optimize with Stochastic Gradient Descent with momentum. The MNIST, CIFAR and OmniGlot experiments start with a batch size of 64, learning rate of 0.02 and momentum of 0.5 [5]. The UCSD-Birds experiment optimizes for a batch size of 32, learning rate of 0.01 [8]. All experiments ran for 30 epochs and testing is done with the best performing validation model. In the OmniArt setup, it is important that we maintain consistent features over all experiments as it is a complex dataset. For this we trained a deep variational autoencoder [10, 16] on the training set, which we continue to use as a feature extractor for all STL and MTL experiments. As the estimator, for both the STL and MTL experiments we use the same structure after the hard shared representation layer of 2048 units. The estimators consist of two 300 unit FC layers, 0.2 dropout and softmax for classification or sigmoid for regression outputs. For the STL experiments we train this structure independently for all seven tasks. In the MTL experiments, it comprises the task specific estimators (branches). We define seven tasks of interest, namely artist attribution (AA), genre classification (GC), creation century classification (CCC), school classification (SC), medium classification (MC), style classification (STC) and creation year estimation (CYE). Different from the MNIST, CIFAR10 and OmniGlot datasets, our tasks are not binary classification tasks. Each one has a different number and type of targets. For the OmniArt experiments we use the Adam optimizer [15] with learning rate of 0.001, batch size of 100 and train for 50 epochs. Unless specified, all nonterminal FC units are ReLU [33] activated. Testing is done with the best performing validation models. 4.3 Results and Discussion Our experimental design explores multiple sharing paradigms for the five datasets. The reported results show the performance with Selective Sharing with Similarity as the best performing approach with Figure 5 showing the formed groups for which performance is shown in Tables 1 and 3. Sharing with similarity yields an accuracy of 99.0% for MNIST. For CIFAR10, sharing with similarity produced an average per task accuracy of 92.7% improving upon both the STL and MTL baseline approaches. Selective Sharing with similarity (expectedly) yields the 0 8 6 9 2 3 5 1 7 4 MNIST ARTIST MEDIUM YEAR SCHOOL CENTURY GENRE STYLE OMNIART DOG CAT DEER BOAT PLANE CAR TRUCK HORSE FROG CHICKEN CIFAR-10 AngloSaxonFuthorc Magi Asomtavruli Atemayar Tibetian Cyrilic Glagolitic Church Slavonic Greek Tagalog Mongolian Avesta Latin Atlantean Futurama Oriya Malay Armenian Katakana Ulog Hiragana Korean Inaktitut Braile Angelic Ge_ez Early Aramaic Burmese Arcadian Hebrew Manipuri Gujarati Gurmukhi Kannada Blackfoot Kebble Mkhedruli N_ko Balinese Bengali Aurek Besh Asomtavruli Grantha Malayalam Sylheti Tengwar Syriac Ojibwe Sanskrit Tifnagh OMNIGLOT UCSD - BIRDS THROAT-GREY THROAT-BROWN UPPER-BROWN UNDER-BUFF UPPER-BUFF BREAST-BUFF BUCK-BUFF HEAD-STRIPE WING-BUFF WING-BROWN Figure 5: Resulting group formations from applying Selective Sharing on MNIST, CIFAR-10, UCSD Birds, OmniGlot and OmniArt. best results (MNIST, CIFAR and OmniGlot), partly because similar letter and number types share the same constructional primitives (see Figure 6). In that way, learning similar alphabets together is expected to improve the performance of the model. Using a superior feature extraction method, data augmentation and parameter tuning can improve the performance in both tasks, but is beyond the purpose of the experiments. For the UCSD-Birds homogeneous ranking problem we compare against a vanilla MTL model, two strong baselines [8, 22] and one state-of-the-art approach [1] in ranking the images containing ten selected bird attributes. Selective Sharing with similarity outperforms all other approaches in seven out of ten tasks. MNIST OMNIART UCSD - BIRDS OMNIGLOT CIFAR-10 Figure 6: Class activation mappings (CAM) for the correctly predicted class. In Row 1 the input image is displayed, Row 2 shows the CAM in Selective Sharing with Similarity with the grouping presented in Figure 5. We can observe that features obtained with Selective Sharing are far more general and feathered when it comes to the activation region, making them more general. Row 3 shows the CAM for the STL baseline and Row 4 the CAM for the MTL baseline. Sharing with similarity produced the best results for the OmniArt dataset overall. The consistent improvement of sharing with similarity over the MTL baseline can be observed in Table 3. E.g. the Dutch school of painting was active in the 1400s - late 1500s. Most of the artists from this period in our OmniArt subset are Dutch masters, which implies that knowing the period and school narrows down the list of possible artists. We could have easily discovered this relation by mining the data itself, but the quadruple correlation in sharing with variance between artists, creation periods, schools and styles is quite intricate and model driven. A qualitative observation from the activation region analysis is that the representations learned with selective sharing are more general and feathered than their STL or MTL counterparts. In addition, as visible the second rows of Figure 6, other than the larger activation span we can observe a similarity between the class activation regions for tasks that formed groups. For example the group formed between '2','3' and '5' in the MNIST tasks exhibits a consistent activation on the curve of the digit in all three tasks. A similar activation can be observed in the below neckline and shoulder area in the Artist, Century, School group in the OmniArt analysis. 5 CONCLUSIONS Selective Sharing is a multi-task learning approach for images in context that allows exploiting task relatedness for group formation without any predefined intertask dependency. Group formation is performed using conditional statements on distances between clusters of task specific gradient factors. This grouping procedure implicitly reduces the trainable parameter space dimensionality and boosts predictive performance for related tasks (or contextual attributes) as a result (see Tables 1, 2, 3). Moreover, Selective Sharing is modality invariant, making it applicable in every multimedia scenario where a supervision signal and multiple targets are available. As such, applied on a wide range of MTL problems, Selective Sharing adjusts the representation learning process to implicitly exploit the entanglement between the contextual attributes and supports learning robust shared representations. On a general note, experimental results on images in context show that forming groups of tasks over which we build a mutual representation is beneficial to the overall learning process. Figure 6 illustrates that the features we obtain are more robust and general in comparison to STL and MTL baselines. Compared to conventional matrix driven MTL approaches, Selective Sharing provides an additional degree of freedom in modeling the tasks at hand, as between task relations need not be studied prior to the classification architecture design. Moreover, the intuition and logic behind the approach is simple and easy to grasp without the need for complex mathematical or statistical apparatus, making Selective Sharing a versatile and useful approach to MTL. Conclusively, sharing is a virtue and knowing who to share with - is awareness. We attempt to teach our models how to do both. ACKNOWLEDGMENTS The authors would like to thank Pascal Mettes for his feedback. This research is supported by the VISTORY project NWO award number 628.007.004. Long Presentation Session 1: Learning and Security ICMR '19, June 10–13, 2019, Ottawa, ON, Canada 78 Long Presentation Session 1: Learning and Security ICMR '19, June 10–13, 2019, Ottawa, ON, Canada 79 Long Presentation Session 1: Learning and Security ICMR '19, June 10–13, 2019, Ottawa, ON, Canada 80 Long Presentation Session 1: Learning and Security ICMR '19, June 10–13, 2019, Ottawa, ON, Canada 81 Long Presentation Session 1: Learning and Security ICMR '19, June 10–13, 2019, Ottawa, ON, Canada 82 Long Presentation Session 1: Learning and Security ICMR '19, June 10–13, 2019, Ottawa, ON, Canada 83 Long Presentation Session 1: Learning and Security ICMR '19, June 10–13, 2019, Ottawa, ON, Canada 84 Long Presentation Session 1: Learning and Security ICMR '19, June 10–13, 2019, Ottawa, ON, Canada 85 Long Presentation Session 1: Learning and Security ICMR '19, June 10–13, 2019, Ottawa, ON, Canada 86</p>
            </sec>
        </body>
        <back>
            <ref-list specific-use="unparsed">
                <ref id="ref-00001">
                    <mixed-citation>Youssef Alami Mejjati, Darren Cosker, and Kwang In Kim. 2018. Multi-task Learning by Maximizing Statistical Dependence. In Proceedings of CVPR.</mixed-citation>
                </ref>
            </ref-list>
        </back>
    </book-part>
</book-part-wrapper>